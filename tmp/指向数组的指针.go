package main

import "fmt"

type grid [9][9]int

func main() {
	var p *[8]int
	p = &[8]int{1, 2, 3, 4, 5, 6, 7, 8}
	fmt.Println(*p)
	var g grid
	var gp *grid
	g[0] = [9]int{0, 1, 2, 3, 4, 5, 6, 7, 8}
	gp = &g
	// gp[1][2] = 1
	// 这样写会空指针引用，
	// 声明了这个指针类型的数组，它里面的值被填充为对应的零值nil
	// 由于Go编译器会对数组类型的指针进行自动解引用，因此当你给[1][2]这个元素赋值的时候
	// 其实发生了隐式的解引用操作
	// 注意，数组不能用make函数来声明
	fmt.Println(g)
	fmt.Println(gp)
	// &[[0 1 2 3 4 5 6 7 8] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0]]
	// 说明这是一个指针类型
	fmt.Println(*gp)
	// [[0 1 2 3 4 5 6 7 8] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0]]
	// 解引用之后得到了一个非指针类型的grid数据
	fmt.Println(gp[1])
	// [0 0 0 0 0 0 0 0 0]
	// 由于gp是一个指针类型，正常来说应该写成(*gp)[1]，但是因为go语言为数组和结构体都提供了自动解引用的特性
	// 所以这里等价于(*gp)[1]
	fmt.Println((*gp)[1])
	// [0 0 0 0 0 0 0 0 0]
	fmt.Println((*gp)[0])
}
