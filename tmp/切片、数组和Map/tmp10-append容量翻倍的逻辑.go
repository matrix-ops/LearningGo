package main

import "fmt"

// 注意，append并不是无脑创建一个两倍于底层数组容度的新数组，而是有一定的规律：
// Go 1.18之后，如果新的期望容量两倍于原有底层数组的容量，那么就使用期望容量
// 如果增长前的切片长度小于等于256，新的底层数组容度将翻倍
// 如果增长前的切片长度大于256，大概会每次增加25%的同时新增（原长度乘以3/4)的容量
// 注意，由于Go编译器内部内存对齐机制的存在，不同类型的切片每次增长的幅度是不一样的,这里计算出来的结果可能并不准确
func main() {
	s1 := make([]int, 256, 256)
	fmt.Println(len(s1), cap(s1))
	s1 = append(s1, 31415926)
	fmt.Println(len(s1), cap(s1))
	s2 := make([]int, 257, 257)
	s2 = append(s2, 31415926)
	fmt.Println("s2的长度和容量是", len(s2), cap(s2))
}
